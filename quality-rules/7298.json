{
    "id": 7298,
    "type": "quality-rule",
    "name": "A Class that has pointer data members must provide a copy Constructor",
    "href": "quality-rules/7298.json",
    "associatedValueName": "Number of violation patterns",
    "description": "The rule searches for all classes containing data members that are pointers and that do not provide a copy constructor. \n\nNote that there is a limitation where a data member is an unknown typedef that is itself a pointer.",
    "output": "Associated to each C++ class with violations, the Quality Rule provides:\n- Number of violation patterns\n- Bookmarks for violation patterns found in the source code:\n  - Pointer class member",
    "rationale": "If you do not define a copy constructor for a class that has pointer members, there is a risk of memory corruption that can lead to crashes or erroneous data.\n\nA copy constructor is a special constructor that can be called to copy an object. The copy constructor for class X has the form X::X(const X&). In the code fragment below, s2 is created by calling String's copy constructor to copy s1:\n\n   String s1(\"Hello, world!\");\n   String s2 (s1);\n\nThe copy constructor is called more often behind the scenes whenever the compiler needs a copy of an object. These objects, appropriately called temporaries, are created and destroyed as they are needed by the compiler. The most common place this occurs is during function calls, so that the semantics of call-by-value can be preserved. For example, here is a function that takes a String argument:\n\n   void DisplayError (const String s);\n\nWhenever DisplayError() is called, the compiler generates a call to the copy constructor for String to create a temporary for parameters. The temporary is then passed to the function.\n\nIf you do not provide a copy constructor, the compiler will generate one for you automatically. This generated copy constructor simply performs a member-wise assignment of all of the data members of a class. This is fine for a class that does not contain any pointer variables, but for pointers this would lead to duplicate references to the same objects with the risk of invalid references and thus of memory corruption and crashes. It is a good idea to get into the habit of always providing the copy constructor for your classes.",
    "remediation": "Define a copy constructor to properly manage pointer data members.",
    "remediationSample": "class MyClass {\n   MyClass( const MyClass&);\n   char * apointermember;\n};\n\nMyClass::MyClass( const MyClass& a)\n{\n   /* Must be adapted to your case */\n   strcpy( apointermember, a.apointermember);\n}",
    "sample": "class MyClass {\n   char * apointermember;\n};",
    "total": "Number C++ classes",
    "businessCriteria": [
        
    ],
    "technologies": [
        {
            "id": -3,
            "name": "C++",
            "href": "technologies/-3.json"
        }
    ]
}
