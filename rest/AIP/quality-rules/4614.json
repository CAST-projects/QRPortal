{
    "id": 4614,
    "name": "DEPRECATED: Proper overriding of 'clone()'",
    "href": "AIP/quality-rules/4614",
    "critical": true,
    "maxWeight": 9,
    "description": "This report lists all Methods overriding 'clone()' and not calling 'super.clone()'",
    "output": "This report lists all Methods overriding 'clone()' and not calling 'super.clone()'.\nIt provides the following information:\n Method full name",
    "rationale": "A call to 'super.clone()' ensures the clone behavior will still work.\nWhen overriding the 'clone()' Method, a call to 'super.clone()' is necessary. Note that where a class 'A' that has a field 'a' of type 'A' and is calling a.clone() without calling super.clone() will not be reported as a violation.",
    "reference": "https://www.vojtechruzicka.com/java-cloning-problems/\nhttps://help.semmle.com/wiki/display/JAVA/Missing+super+clone",
    "remediation": "Review the Method definition",
    "remediationSample": "class Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    \n    public Person clone() {\n        try {\n            return (Person)super.clone(); // FIXED 'clone' correctly calls 'super.clone'\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should never happen\");\n        }\n    }\n}",
    "sample": "class Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    \n    public Person clone() {\n        return new Person(this.name); // violation \n    }\n}",
    "total": "Number of Java methods",
    "alternativeName": "A clone method that is overridden in a subclass should call super.clone. Not doing so causes the subclass clone to return an object of the wrong type.",
    "businessCriteria": [
        {
            "id": 60012,
            "name": "Changeability",
            "href": "AIP/business-criteria/60012"
        },
        {
            "id": 66031,
            "name": "Programming Practices",
            "href": "AIP/business-criteria/66031"
        },
        {
            "id": 60013,
            "name": "Robustness",
            "href": "AIP/business-criteria/60013"
        },
        {
            "id": 60011,
            "name": "Transferability",
            "href": "AIP/business-criteria/60011"
        }
    ],
    "technicalCriteria": [
        {
            "id": 61010,
            "name": "Complexity - OO Inheritance and Polymorphism",
            "weight": 9,
            "critical": true
        },
        {
            "id": 61003,
            "name": "Programming Practices - OO Inheritance and Polymorphism",
            "weight": 9,
            "critical": true
        }
    ],
    "technologies": [
        {
            "id": 140029,
            "name": "JEE",
            "href": "AIP/technologies/140029"
        }
    ],
    "qualityStandards": [
        {
            "standard": "CWE",
            "id": "CWE-580",
            "name": "clone() Method Without super.clone()",
            "url": "https://cwe.mitre.org/data/definitions/580.html",
            "description": "The software contains a clone() method that does not call super.clone() to obtain the new object."
        },
        {
            "standard": "OWASP",
            "id": "M7-2016",
            "name": "Poor Code Quality",
            "url": "https://www.owasp.org/index.php/Mobile_Top_10_2016-M7-Poor_Code_Quality",
            "description": "Code quality issues are fairly prevalent within most mobile code. The good news is that most code quality issues are fairly benign and result in bad programming practice. It is typically difficult to detect these types of issues through manual code review. Instead, attackers will use third-party tools that perform static analysis or perform fuzzing. These types of tools will typically identify memory leaks, buffer overflows, and other less severe issues that result in bad programming practice. Hackers with extreme low-level knowledge and expertise are able to effectively exploit these types of issues. The typical primary goal is to execute foreign code within the mobile code's address space."
        }
    ],
    "parameters": [
        
    ],
    "thresholds": [
        98.0,
        99.0,
        99.5,
        99.99
    ]
}
