{
    "id": 1039058,
    "name": "Avoid Use of Insufficiently Random Generated keys in cookies",
    "href": "AIP/quality-rules/1039058",
    "critical": true,
    "associatedValueName": "Number of violation occurrences",
    "description": "The software may use insufficiently random numbers or values in a security context that depends on unpredictable numbers.\n\nIt checks only cookie uses the valid random generated value.\n\nExceptions:\n\n1. Will not check across files.\n2. ESAPI Encoder.",
    "output": "Associated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code",
    "rationale": "When software generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that will be generated, and use this guess to impersonate another user or access sensitive information.",
    "reference": "http://cwe.mitre.org/data/definitions/330.html",
    "remediation": "Use of Cryptographic Random Generator\n\nString GenerateReceiptURL(String baseUrl) {\nSecureRandom ranGen = new SecureRandom();\nranGen.setSeed((new Date()).getTime());\nreturn(baseUrl + ranGen.nextInt(400000000) + \".html\");\n}",
    "remediationSample": "SecureRandom sr = new SecureRandom();\nsr.setSeed(somevalue);\nint value = sr.nextInt(1000);\nString rememberMeKey = Double.toString(value).substring(2); // Trim off the 0. at the front.\nString user = \"Doug\";\nString fullClassName = this.getClass().getName();\nString testCaseNumber = fullClassName.substring(fullClassName.lastIndexOf('.')1\"BenchmarkTest\".length());\nuser+= testCaseNumber;\nString cookieName = \"rememberMe\" + testCaseNumber;\njavax.servlet.http.Cookie rememberMe = new javax.servlet.http.Cookie(cookieName, rememberMeKey);\nrememberMe.setSecure(true);\n// rememberMe.setPath(\"/benchmark/\" + this.getClass().getSimpleName());\nrememberMe.setPath(request.getRequestURI()); // i.e., set path to JUST this servlet\n// e.g., /benchmark/sql-01/BenchmarkTest01001\nrequest.getSession().setAttribute(cookieName, rememberMeKey);\nresponse.addCookie(rememberMe);\nresponse.getWriter().println(\nuser + \" has been remembered with cookie: \" + rememberMe.getName() \n+ \" whose value is: \" + rememberMe.getValue() + \"<br/>\"\n);",
    "sample": "Sample code 1:\ndouble value = java.lang.Math.random();\nString rememberMeKey = Double.toString(value).substring(2); // Trim off the 0. at the front.\n\nString user = \"Doug\";\nString fullClassName = this.getClass().getName();\nString testCaseNumber = fullClassName.substring(fullClassName.lastIndexOf('.')1\"BenchmarkTest\".length());\nuser+= testCaseNumber;\n\nString cookieName = \"rememberMe\" + testCaseNumber;\n\njavax.servlet.http.Cookie rememberMe = new javax.servlet.http.Cookie(cookieName, rememberMeKey);\nrememberMe.setSecure(true);\n//  rememberMe.setPath(\"/benchmark/\" + this.getClass().getSimpleName());\nrememberMe.setPath(request.getRequestURI()); // i.e., set path to JUST this servlet\n// e.g., /benchmark/sql-01/BenchmarkTest01001\nrequest.getSession().setAttribute(cookieName, rememberMeKey);\nresponse.addCookie(rememberMe);\nresponse.getWriter().println(\nuser + \" has been remembered with cookie: \" + rememberMe.getName() \n+ \" whose value is: \" + rememberMe.getValue() + \"<br/>\"\n);\n------------------------------------------\nSample code 2;\nIf the cookie is generated using\nint randNumber = new java.util.Random().nextInt(99) also to be set as violation\nAttaching the source code sample file\n\n------------------------------------------\nSample code 3 :\n\ndouble value = java.lang.Math.random();\nString rememberMeKey = Double.toString(value).substring(2); // Trim off the 0. at the front.\n\nString user = \"Doug\";\nString fullClassName = this.getClass().getName();\nString testCaseNumber = fullClassName.substring(fullClassName.lastIndexOf('.')1\"BenchmarkTest\".length());\nuser+= testCaseNumber;\n\nString cookieName = \"rememberMe\" + testCaseNumber;\n\n------------------------------------------\nSample code 4 :\nnew java.util.Random().nextBytes(bytes);\nString rememberMeKey = org.owasp.esapi.ESAPI.encoder().encodeForBase64(bytes, true);\n\nString user = \"Byron\";\nString fullClassName = this.getClass().getName();\nString testCaseNumber = fullClassName.substring(fullClassName.lastIndexOf('.')1\"BenchmarkTest\".length());\nuser+= testCaseNumber;\n\nString cookieName = \"rememberMe\" + testCaseNumber;\n------------------------------------------\nSample code 5:\nlong l = new java.util.Random().nextLong();\nString rememberMeKey = Long.toString(l);\n\nString user = \"Logan\";\nString fullClassName = this.getClass().getName();\nString testCaseNumber = fullClassName.substring(fullClassName.lastIndexOf('.')1\"BenchmarkTest\".length());\nuser+= testCaseNumber;\n\nString cookieName = \"rememberMe\" + testCaseNumber;",
    "total": "Number of Java Artifacts",
    "businessCriteria": [
        {
            "id": 20140522,
            "name": "Green Stuff",
            "href": "AIP/business-criteria/20140522"
        },
        {
            "id": 60016,
            "name": "Security",
            "href": "AIP/business-criteria/60016"
        }
    ],
    "technicalCriteria": [
        {
            "id": 66064,
            "name": "Secure Coding - Weak Security Features",
            "weight": 7,
            "critical": true
        }
    ],
    "technologies": [
        {
            "id": 140029,
            "name": "JEE",
            "href": "AIP/technologies/140029"
        }
    ],
    "qualityStandards": [
        {
            "standard": "STIG-V4R8",
            "id": "STIG-V-70217",
            "name": "The application must use the Federal Information Processing Standard (FIPS) 140-2-validated cryptographic modules and random number generator if the application implements encryption, key exchange, digital signature, and hash functionality.",
            "url": null,
            "description": "Sequentially generated session IDs can be easily guessed by an attacker. Employing the concept of randomness in the generation of unique session identifiers helps to protect against brute-force attacks to determine future session identifiers.\n\nUnique session IDs address man-in-the-middle attacks, including session hijacking or insertion of false information into a session. If the attacker is unable to identify or guess the session information related to pending application traffic, they will have more difficulty in hijacking the session or otherwise manipulating valid sessions.\n\nThis requirement focuses on communications protection for the application session rather than for the network packet.\n\nThis requirement applies to applications that utilize communications sessions. This includes, but is not limited to, web-based applications and Service-Oriented Architectures (SOA)."
        }
    ],
    "parameters": [
        
    ],
    "thresholds": [
        98.0,
        99.0,
        99.5,
        99.99
    ]
}
