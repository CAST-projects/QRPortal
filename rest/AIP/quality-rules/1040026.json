{
    "id": 1040026,
    "name": "A Single HTTP method should be explicitly specified in @RequestMapping methods",
    "href": "AIP/quality-rules/1040026",
    "critical": true,
    "associatedValueName": "Number of violation occurrences",
    "description": "By default, @RequestMapping method handles all matching requests: A method you intended only to be POST-ed to could also be called by a GET, thereby allowing hackers to call the method inappropriately.\n\nFor example a \"transferFunds\" method might be invoked like so: <img src=\"http://bank.com/actions/transferFunds?reciepientRouting=000000&receipientAccount=11111111&amount=200.00\" width=\"1\" height=\"1\"/>\n\nThis rule will check is a single HTTP method, with which you expect @RequestMapping Java method to be called, is explicitly listed. If not, a violation is reported ( The method is completely missing or the method parameter is configured by mixing GET and POST verbs)",
    "output": "Associated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code",
    "rationale": "The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.",
    "reference": "https://cwe.mitre.org/data/definitions/352.html",
    "remediation": "Specify HTTP method with which you expect your @RequestMapping Java method to be called.\nExample: @RequestMapping(\"/greet\", method = GET)",
    "remediationSample": "@RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {...",
    "sample": "@RequestMapping(\"/greet\", )\n  public String greet(String greetee) { ....",
    "total": "Number of Java methods having @RequestMapping",
    "alternativeName": "Ensure explicitly specifying single HTTP method in @RequestMapping methods to avoid information leakage",
    "businessCriteria": [
        {
            "id": 20140522,
            "name": "Green Stuff",
            "href": "AIP/business-criteria/20140522"
        },
        {
            "id": 60016,
            "name": "Security",
            "href": "AIP/business-criteria/60016"
        }
    ],
    "technicalCriteria": [
        {
            "id": 66064,
            "name": "Secure Coding - Weak Security Features",
            "weight": 8,
            "critical": true
        }
    ],
    "technologies": [
        {
            "id": 140029,
            "name": "JEE",
            "href": "AIP/technologies/140029"
        }
    ],
    "qualityStandards": [
        {
            "standard": "CWE",
            "id": "CWE-352",
            "name": "Cross-Site Request Forgery (CSRF)",
            "url": "https://cwe.mitre.org/data/definitions/352.html",
            "description": "The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request."
        },
        {
            "standard": "NIST-SP-800-53R4",
            "id": "NIST-IA-9",
            "name": "Service Identification and Authentication",
            "url": "https://nvd.nist.gov/800-53/Rev4/control/IA-9",
            "description": null
        },
        {
            "standard": "OWASP",
            "id": "A2-2017",
            "name": "Broken Authentication",
            "url": "https://www.owasp.org/index.php/Top_10-2017_A2-Broken_Authentication",
            "description": "Application functions related to authentication and session management are often implemented incorrectly, allowing attackers to compromise passwords, keys, or session tokens, or to exploit other implementation flaws to assume other users' identities temporarily or permanently."
        },
        {
            "standard": "OWASP",
            "id": "A8-2013",
            "name": "Cross-Site Request Forgery (CSRF)",
            "url": "https://www.owasp.org/index.php/Top_10_2013-A8-Cross-Site_Request_Forgery_(CSRF)",
            "description": "A CSRF attack forces a logged-on victims' browser to send a forged HTTP request, including the victims' session cookie and any other automatically included authentication information, to a vulnerable web application. This allows the attacker to force the victims' browser to generate requests the vulnerable application thinks are legitimate requests from the victim."
        },
        {
            "standard": "PCI-DSS-V3.1",
            "id": "PCI-Requirement-6.5.9",
            "name": "Cross-site request forgery (CSRF)",
            "url": null,
            "description": null
        },
        {
            "standard": "STIG-V4R8",
            "id": "STIG-V-70259",
            "name": "The application must protect from Cross-Site Request Forgery (CSRF) vulnerabilities.",
            "url": null,
            "description": "Cross-Site Request Forgery (CSRF) is an attack where a website user is forced to execute an unwanted action on a website that he or she is currently authenticated to. An attacker, through social engineering (e.g., e-mail or chat) creates a hyperlink which executes unwanted actions on the website the victim is authenticated to and sends it to the victim. If the victim clicks on the link, the action is executed unbeknownst to the victim.\n\nA CSRF attack executes a website request on behalf of the user which can lead to a compromise of the user\u2019s data. What is needed to be successful is for the attacker to know the URL, an authenticated application user, and trick the user into clicking the malicious link.\n\nWhile XSS is not needed for a CSRF attack to work, XSS vulnerabilities can provide the attacker with a vector to obtain information from the user that may be used in mitigating the risk. The application must not be vulnerable to XSS as an XSS attack can be used to help defeat token, double-submit cookie, referrer and origin-based CSRF defenses."
        }
    ],
    "parameters": [
        
    ],
    "thresholds": [
        98.0,
        99.0,
        99.5,
        99.99
    ]
}
