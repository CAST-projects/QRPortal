{
    "id": 7732,
    "name": "Avoid non validated inputs",
    "href": "AIP/quality-rules/7732",
    "critical": true,
    "description": "Reports all input field that is not validated in JSP files that use JSF (i.e. reference the JSF core taglib). Faces handles validation in three ways - \nvia standard validation, custom validation, validation in the backing bean.\n\nNote that the other way that consist in making the validation in the application (in the method called when a button is selected like createEmail method in the Example section)  is not considered. In this case, a manual check will be needed to validate if the validation is made or not through this way.",
    "output": "This report lists all input that are not validated. It provides the following information:\n  JSP Input Field Full Name",
    "rationale": "Input validation is required to secure an application. Moreover, the web interface is exposed to anyone. Non validating input may allow injecting arbitrary web script, HTML, SQL... Consequences can be severe, like erasing the content of a database.\nOnly one invalidated input can be exploited by an attacker.\n\nJSF supports validators, which are responsible for making sure that the user enters an acceptable value. Each input control must be associated with one or more validators.",
    "reference": "Java Server Faces in Action ISBN 1-932394-11-7 p 44",
    "remediation": "Validate each input field through one of  the three ways - at the UI component level, via validator methods in backing beans, or in validator classes.\nUI components generally handle simple validation, such as whether a value is required, or validation logic that's specific to the component itself (and therefore not usable with other components).\nValidator methods are useful when you need to validate one or more\nfields on a form (and you don't need to share that logic with other components). External validators are useful for generic cases like the length of a field or a number range; they are pluggable, which means you can attach one or more of them to any component.",
    "remediationSample": "-------------- 1st sample (standard validation) --------------\n\n----> JSP file\n<%@taglib prefix=\"f\" uri=\"http://java.sun.com/jsf/core\"%>\n<%@taglib prefix=\"h\" uri=\"http://java.sun.com/jsf/html\"%>\n\n<h:inputText id=\"age\" value=\"#{UserRegistration.user.age}\">\n          <f:validateLongRange maximum=\"150\" minimum=\"0\"/>\n</h:inputText>\n\n----> jsf_core.tld\n<tag>\n    <name>validateLongRange</name>\n    <tag-class>\n     com.sun.faces.taglib.jsf_core.ValidateLongRangeTag\n    </tag-class>\n...\n\n----> ValidateLongRangeTag.java:\npublic class ValidateLongRangeTag extends com.sun.faces.taglib.jsf_core.MaxMinValidatorTag {\n....\n}\n\n---> MaxMinValidatorTag.java:\npublic class MaxMinValidatorTag extends javax.faces.webapp.ValidatorTag {\n  ...\n}\n\n\n-------------- 2nd sample ( custom validation) --------------\n----> JSP file:\n<%@taglib prefix=\"f\" uri=\"http://java.sun.com/jsf/core\"%>\n<%@taglib prefix=\"h\" uri=\"http://java.sun.com/jsf/html\"%>\n\n<h:inputText id=\"emailInput\"\n               value=\"#{registrationBean.email}/>\n      <f:validator validatorId=\"emailValidator\"/> // FIXED\n</h:inputText>\n\n----> faces-config.xml\n<faces-config>\n  ...\n       <validator>\n            <validator-id>emailValidator</validator-id>\n            <validator-class>com.sample.EmailValidator</validator-class>\n        </validator>\n  ... \n\n</faces-config>\n\n----> EmailValidator.java\npackage com.sample;\n\npublic class EmailValidator implements javax.faces.validator.Validator {\n    ....\n}\n\n\n-------------- 3rd sample ( validation in the backing bean) --------------\n----> JSP file:\n<h:inputText id=\"emailInput\"\n            validator=\"#{registrationBean.validateEmail}\" // FIXED\n            value=\"#{registrationBean.email}/>\n\n----> faces-config.xml\n<faces-config>\n...\n    <managed-bean>\n        <managed-bean-name>registrationBean</managed-bean-name>\n        <managed-bean-class>\n            com.sample.registrationBean\n        </managed-bean-class>\n        <managed-bean-scope>session</managed-bean-scope>\n    </managed-bean> \n...\n</faces-config>\n\n----> RegistrationBean.java\npackage com.sample;\n\n\npublic class RegistrationBean {\n    ...\n    public void validateEmail(FacesContext context, UIComponent validate, Object value){\n       ...\n    }\n}",
    "sample": "----> JSP file (1st sample: standard validation)\n<%@taglib prefix=\"f\" uri=\"http://java.sun.com/jsf/core\"%>\n<%@taglib prefix=\"h\" uri=\"http://java.sun.com/jsf/html\"%>\n\n<h:inputText id=\"age\" value=\"#{UserRegistration.user.age}\"> // VIOLATION\n</h:inputText>\n\n----> JSP file (for 2nd, 3rd and 4th sample)\n<%@taglib prefix=\"f\" uri=\"http://java.sun.com/jsf/core\"%>\n<%@taglib prefix=\"h\" uri=\"http://java.sun.com/jsf/html\"%>\n\n<h:form id=\"create\"> \n     ....\n\n     <h:inputText id=\"emailInput\"\n            value=\"#{registrationBean.email}/> // VIOLATION\n\n     <h:commandButton id=\"submit\" \n                                  value=\"CreateEmail\"\n                                  action=\"#{registrationBean.createEmail}\"/>\n     ....\n</h:form>\n\n---> faces-config.xml\n<faces-config>\n...\n    <managed-bean>\n        <managed-bean-name>registrationBean</managed-bean-name>\n        <managed-bean-class>\n            com.sample.registrationBean\n        </managed-bean-class>\n        <managed-bean-scope>session</managed-bean-scope>\n    </managed-bean> \n...\n</faces-config>\n\n---> RegistrationBean.java\npackage com.sample;\n\npublic class RegistrationBean {\n    ...\n\n    }\n}",
    "total": "Number of input field, 0 if JSF is not used",
    "businessCriteria": [
        {
            "id": 66031,
            "name": "Programming Practices",
            "href": "AIP/business-criteria/66031"
        },
        {
            "id": 60016,
            "name": "Security",
            "href": "AIP/business-criteria/60016"
        }
    ],
    "technicalCriteria": [
        {
            "id": 66062,
            "name": "Secure Coding - Input Validation",
            "weight": 9,
            "critical": true
        }
    ],
    "technologies": [
        {
            "id": 140029,
            "name": "JEE",
            "href": "AIP/technologies/140029"
        }
    ],
    "qualityStandards": [
        {
            "standard": "CISQ",
            "id": "ASCSM-CWE-99",
            "name": "Name or Reference Resolution Improper Input Neutralization",
            "url": null,
            "description": "Objective\nAvoid failure to sanitize user input in use as resource names or references\n\nConsequence\nSoftware unaware of resource identification control incurs the risk of unauthorized access to or modification of sensitive data and system resources, including configuration files and files containing sensitive information\n\nMeasure Element\nNumber of instances where an external value is entered into the application through the user interface ReadsUI action, transformed throughout the application along the sequence composed of ActionElements with DataRelations relations, some of which being part of named callable and method control elements, and ultimately used in the in the platform action to access a resource by its name; none of the callable or method control element of the transformation sequence being a vetted sanitization control element from the list of vetted sanitization control elements.\n\n"
        },
        {
            "standard": "CWE",
            "id": "CWE-99",
            "name": "Improper Control of Resource Identifiers ('Resource Injection')",
            "url": "https://cwe.mitre.org/data/definitions/99.html",
            "description": "The software receives input from an upstream component, but it does not restrict or incorrectly restricts the input before it is used as an identifier for a resource that may be outside the intended sphere of control."
        },
        {
            "standard": "NIST-SP-800-53R4",
            "id": "NIST-SI-10",
            "name": "Information Input Validation",
            "url": "https://nvd.nist.gov/800-53/Rev4/control/SI-10",
            "description": null
        },
        {
            "standard": "OWASP",
            "id": "A3-2013",
            "name": "Cross-Site Scripting (XSS)",
            "url": "https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)",
            "description": "XSS flaws occur whenever an application takes untrusted data and sends it to a web browser without proper validation or escaping. XSS allows attackers to execute scripts in the victims' browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites."
        },
        {
            "standard": "OWASP",
            "id": "A7-2017",
            "name": "Cross-Site Scripting (XSS)",
            "url": "https://www.owasp.org/index.php/Top_10-2017_A7-Cross-Site_Scripting_(XSS)",
            "description": "XSS flaws occur whenever an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites."
        },
        {
            "standard": "PCI-DSS-V3.1",
            "id": "PCI-Requirement-6.5.1",
            "name": "Injection flaws, particularly SQL injection. Also consider OS Command Injection, LDAP and XPath injection flaws as well as other injection flaws.",
            "url": null,
            "description": null
        },
        {
            "standard": "STIG-V4R8",
            "id": "STIG-V-70265",
            "name": "The application must validate all input.",
            "url": null,
            "description": "Checking the valid syntax and semantics of information system inputs (e.g., character set, length, numerical range, and acceptable values) verifies that inputs match specified definitions for format and content. Software applications typically follow well-defined protocols that use structured messages (i.e., commands or queries) to communicate between software modules or system components. \n\nStructured messages can contain raw or unstructured data interspersed with metadata or control information. If software applications use attacker-supplied inputs to construct structured messages without properly encoding such messages, then the attacker could insert malicious commands or special characters that can cause the data to be interpreted as control information or metadata. \n\nConsequently, the module or component that receives the tainted output will perform the wrong operations or otherwise interpret the data incorrectly. Prescreening inputs prior to passing to interpreters prevents the content from being unintentionally interpreted as commands. Input validation helps to ensure accurate and correct inputs and prevent attacks such as cross-site scripting and a variety of injection attacks.\n\nAbsence of input validation opens an application to improper manipulation of data. The lack of input validation can lead immediate access of application, denial of service, and corruption of data.\n\nInvalid input includes presence of scripting tags within text fields, query string manipulation, and invalid data types and sizes.\n\nWhen an application validates input, it will only execute provided input after it has evaluated the input, validated the input and determined the data is in an expected format, and content is not extraneous or malformed.\n\nComprehensive application security testing and code reviews are required to ensure the application is not vulnerable to input validation vulnerabilities.\n\nApplication security code reviews should be conducted during the development phase to find and address input validation errors. When code reviews are not possible, fuzz testing can be performed on the application to attempt and identify vulnerable data input fields."
        },
        {
            "standard": "STIG-V4R8",
            "id": "STIG-V-70271",
            "name": "The application must not be subject to input handling vulnerabilities.",
            "url": null,
            "description": "A common application vulnerability is unpredictable behavior due to improper input validation. This requirement guards against adverse or unintended system behavior caused by invalid inputs, where information system responses to the invalid input may be disruptive or cause the system to fail into an unsafe state.\n\nData received from the user should always be suspected as being malicious and always validated prior to using it as input to the application.\n\nSome examples of input methods:\n\n- Forms Data\n- URL parameters\n- Hidden Fields\n- Cookies\n- HTTP Headers or anything in the HTTP request\n- Client data entry fields\n\nItems to validate:\n\n- Out of range values/Boundary \n- Data length \n- Validate types of characters allowed\n- Whitelist validation for known good data input while denying all other input.\n\nOther recommendations include: \n\n- Using drop down menus for lists\n- Validating input on the server, not on the client.\n\nIf validating on the client, also validate on the server:\n\n- Using regular expressions to validate input\n- Using HTML filter libraries that implement input validation tasks."
        }
    ],
    "parameters": [
        
    ],
    "thresholds": [
        98.0,
        99.0,
        99.5,
        99.99
    ]
}
