{
    "id": 1065110,
    "name": "Ensure arrays and containers are accessed using unsigned values",
    "href": "AIP/quality-rules/1065110",
    "critical": true,
    "maxWeight": 8,
    "description": "The rule will raise a violation when signed counters/iterators/parameters are used",
    "output": "Associated to each violation, the following information is provided:\n- The number of violation occurrences\n- Bookmarks for violation occurrences found in the source code",
    "rationale": "When using standard template library vectors, the programmer is responsible for ensuring integer indexes are within the bounds of the vector to prevent out-of-bounds write. Even when checks are performed for range, there are possibilities for the indices to be of a signed type and hence go out of bounds.\nTypically, this can result in the corruption of data, a crash, or code execution. The software may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent write operation then produces undefined or unexpected results.",
    "reference": "https://cwe.mitre.org/data/definitions/787.html\nhttps://cwe.mitre.org/data/definitions/119.html\nhttps://cwe.mitre.org/data/definitions/120.html\nhttps://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range",
    "remediation": "Always use unsigned type for range check.",
    "remediationSample": "1. #include <cstddef>\n  \nvoid insert_in_table(int *table, std::size_t tableSize, \nstd::size_t pos, // compliant - unsigned pos\nint value) {\n  if (pos >= tableSize) {\n    // Handle error\n    return;\n  }\n  table[pos] = value;\n}\n\n\n2. \n#include <vector>\n  \nvoid insert_in_table(std::vector<int> &table, std::size_t pos, int value) {\n  if (pos >= table.size()) {\n    // Handle error\n    return;\n  }\n  table[pos] = value;\n}",
    "sample": "1. \nvoid insert_in_table(int *table, std::size_t tableSize, \nint pos, //Non-compilant\nint value) {\n  if (pos >= tableSize) {\n    // Handle error\n    return;\n  }\n  table[pos] = value;\n}\n\n\n2. \n#include <vector>\n  \nvoid insert_in_table(std::vector<int> &table, long long pos, int value) {\n  if (pos >= table.size()) {\n    // Handle error\n    return;\n  }\n  table[pos] = value;\n}",
    "total": "Number of C++ methods and Functions",
    "alternativeName": "Ensure arrays and containers are accessed using unsigned values",
    "businessCriteria": [
        {
            "id": 1062100,
            "name": "CISQ-Index",
            "href": "AIP/business-criteria/1062100"
        },
        {
            "id": 1062103,
            "name": "CISQ-Reliability",
            "href": "AIP/business-criteria/1062103"
        },
        {
            "id": 1062104,
            "name": "CISQ-Security",
            "href": "AIP/business-criteria/1062104"
        },
        {
            "id": 20140522,
            "name": "GreenIT-Index",
            "href": "AIP/business-criteria/20140522"
        },
        {
            "id": 1061000,
            "name": "ISO-5055-Index",
            "href": "AIP/business-criteria/1061000"
        },
        {
            "id": 1061003,
            "name": "ISO-5055-Reliability",
            "href": "AIP/business-criteria/1061003"
        },
        {
            "id": 1061004,
            "name": "ISO-5055-Security",
            "href": "AIP/business-criteria/1061004"
        },
        {
            "id": 60013,
            "name": "Robustness",
            "href": "AIP/business-criteria/60013"
        },
        {
            "id": 60016,
            "name": "Security",
            "href": "AIP/business-criteria/60016"
        }
    ],
    "technicalCriteria": [
        {
            "id": 1062145,
            "name": "ASCRM-CWE-120 - Buffer Copy without Checking Size of Input",
            "weight": 5,
            "critical": false
        },
        {
            "id": 1062174,
            "name": "ASCSM-CWE-120 - Buffer Copy without Checking Size of Input",
            "weight": 5,
            "critical": false
        },
        {
            "id": 1061021,
            "name": "CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer",
            "weight": 5,
            "critical": false
        },
        {
            "id": 1061022,
            "name": "CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
            "weight": 5,
            "critical": false
        },
        {
            "id": 1061090,
            "name": "CWE-787: Out-of-bounds Write",
            "weight": 5,
            "critical": false
        },
        {
            "id": 66069,
            "name": "Programming Practices - Unexpected Behavior",
            "weight": 8,
            "critical": true
        }
    ],
    "technologies": [
        {
            "id": -2,
            "name": "C",
            "href": "AIP/technologies/-2"
        },
        {
            "id": -3,
            "name": "C++",
            "href": "AIP/technologies/-3"
        }
    ],
    "qualityStandards": [
        {
            "standard": "CISQ",
            "id": "ASCRM-CWE-120",
            "name": "Buffer Copy without Checking Size of Input",
            "url": null,
            "description": "Objective\nAvoid buffer operations among buffers with incompatible sizes\n\nConsequence\nSoftware featuring known weak coding practices results in unexpected and erroneous behaviors\n\nMeasure Element\nNumber of instances in which the content of the first buffer is moved into the content of the second buffer while the size of the first buffer is greater than the size of the second buffer.\n\n"
        },
        {
            "standard": "CISQ",
            "id": "ASCSM-CWE-120",
            "name": "Buffer Copy without Checking Size of Input",
            "url": null,
            "description": "Objective\nAvoid buffer operations among buffers with incompatible sizes\n\nConsequence\nSoftware that is unaware of buffer bounds incurs the risk of corruption of relevant memory, and perhaps instructions, possibly leading to a crash, the risk of data integrity loss, and the risk of unauthorized access to sensitive data\n\nMeasure Element\nNumber of instances in which the content of the first buffer is moved into the content of the second buffer while the size of the first buffer is greater than the size of the second buffer.\n\n"
        },
        {
            "standard": "CWE",
            "id": "CWE-119",
            "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
            "url": "https://cwe.mitre.org/data/definitions/119.html",
            "description": "The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer."
        },
        {
            "standard": "CWE",
            "id": "CWE-120",
            "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
            "url": "https://cwe.mitre.org/data/definitions/120.html",
            "description": "The program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow."
        },
        {
            "standard": "CWE",
            "id": "CWE-787",
            "name": "Out-of-bounds Write",
            "url": "https://cwe.mitre.org/data/definitions/787.html",
            "description": "The software writes data past the end, or before the beginning, of the intended buffer."
        },
        {
            "standard": "ISO-5055",
            "id": "CWE-119",
            "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
            "url": "https://cwe.mitre.org/data/definitions/119.html",
            "description": "The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer."
        },
        {
            "standard": "ISO-5055",
            "id": "CWE-120",
            "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
            "url": "https://cwe.mitre.org/data/definitions/120.html",
            "description": "The program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow."
        },
        {
            "standard": "ISO-5055",
            "id": "CWE-787",
            "name": "Out-of-bounds Write",
            "url": "https://cwe.mitre.org/data/definitions/787.html",
            "description": "The software writes data past the end, or before the beginning, of the intended buffer."
        },
        {
            "standard": "NIST-SP-800-53R4",
            "id": "NIST-SI-16",
            "name": "Memory Protection",
            "url": "https://nvd.nist.gov/800-53/Rev4/control/SI-16",
            "description": null
        },
        {
            "standard": "OMG-ASCQM",
            "id": "CWE-119",
            "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
            "url": "https://cwe.mitre.org/data/definitions/119.html",
            "description": "The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer."
        },
        {
            "standard": "OMG-ASCQM",
            "id": "CWE-120",
            "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
            "url": "https://cwe.mitre.org/data/definitions/120.html",
            "description": "The program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow."
        },
        {
            "standard": "OMG-ASCQM",
            "id": "CWE-787",
            "name": "Out-of-bounds Write",
            "url": "https://cwe.mitre.org/data/definitions/787.html",
            "description": "The software writes data past the end, or before the beginning, of the intended buffer."
        },
        {
            "standard": "PCI-DSS-V3.1",
            "id": "PCI-Requirement-6.5.2",
            "name": "Buffer overflows",
            "url": null,
            "description": null
        },
        {
            "standard": "PCI-DSS-V3.2.1",
            "id": "PCI-Requirement-6.5.2",
            "name": "Buffer overflows",
            "url": null,
            "description": null
        },
        {
            "standard": "STIG-V4R8",
            "id": "STIG-V-70277",
            "name": "The application must not be vulnerable to overflow attacks.",
            "url": null,
            "description": "A buffer overflow occurs when a program exceeds the amount of data allocated to a buffer. The buffer is a sequential section of memory and when the data is written outside the memory bounds, the program can crash or malicious code can be executed.\n\nSecurity safeguards employed to protect memory include, for example, data execution prevention and address space layout randomization. Data execution prevention safeguards can either be hardware-enforced or software-enforced with hardware providing the greater strength of mechanism.\n\nBuffer overflows can manifest as stack overflows, heap overflows integer overflows and format string overflows. Each type of overflow is dependent upon the underlying application language and the context in which the overflow is executed.\n\nInteger overflows can lead to infinite looping when loop index variables are compromised and cause a denial of service.  If the integer is used in data references, the data can become corrupt. Also, using the integer in memory allocation can cause buffer overflows, and a denial of service.  Integers used in access control mechanisms can potentially trigger buffer overflows, which can be used to execute arbitrary code. \n\nAlmost all known web servers, application servers, and web application environments are susceptible to buffer overflows. Proper validation of user input is required to mitigate the risk. Notably, limiting the size of the strings a user is allowed to input to a program to a predetermined, acceptable length.\n\nA code review, static code analysis or active vulnerability or fuzz testing are methods used to identify overflows within application code."
        }
    ],
    "parameters": [
        
    ],
    "thresholds": [
        98.0,
        99.0,
        99.5,
        99.99
    ]
}
